# TypeScript学习

# 1. TypeScript：初体验

## 1.1 TypeScript概述

![请添加图片描述](https://img-blog.csdnimg.cn/ee7cf4510b614e69bd0685283072d17f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlcnRpbA==,size_16,color_FFFFFF,t_70)

**TS增加了什么？**

1. 类型
2. 支持ES的新特性
3. 添加ES不具备的新特性，比如接口、枚举...
4. 丰富的配置选项，比如可以设置编译成任意版本的ES
5. 强大的开发工具

## 1.2 TypeScript开发环境的搭建

1. 下载Node.js
2. 安装Node.js
3. 使用npm全局安装TypeScript
   1. 进入命令行
   2. 输入：`npm i -g typescript`(Mac用户要进入sudo)
4. 创建一个ts文件
5. 使用tsc命令对ts文件进行编译
   1. 进入命令行
   2. 进入ts文件所在目录
   3. 执行命令：`tsc xxx.ts`

## 1.3 第一个案例

	* 新建一个空文件夹 创建hello.ts文件

`chapter01/part1/01_helloTS.ts`

```typescript
console.log('Hello TS');
```

	* 在命令行使用tsc命令编译

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607152352046.png" alt="image-20230607152352046" style="zoom:50%;" />

我们就发现编译完成后生成了js文件 这就是tsc编译器的作用

# 2. TypeScript：类型声明和变量类型

## 2.1 类型声明

	* 直接在变量声明后面加

`chapter01/part2/02_basis.ts`

```typescript
// 表示我们声明一个变量a，同时指定它的类型为number
let a: number

// a的类型设置为了number，a的值只能是数字
a = 10
a = 33
// a = 'hello' // 此行代码会报错 因为变量a的类型是number 不能赋值字符串 但是可以编译成js
let b: string
// b = 123
```

	* 如果变量的声明和赋值是同时进行的，TS可以自动对变量类型进行检测

```typescript
// 声明完变量直接进行赋值
// let c: boolean = true

// 如果变量的声明和赋值是同时进行的，ts可以自动对变量进行类型检测
let c = false
c = true
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607185059956.png" alt="image-20230607185059956" style="zoom:50%;" />

	* 此外我们还可以对函数的参数、返回值的类型进行声明

```typescript
// JS中的函数是不考虑参数的类型和个数的
// function sum(a, b){
//     return a + b
// }
// console.log(sum(123, 456)) // 579
// console.log(sum(123, '456')); // '123456'

function sum(a: number, b: number): number{
    // 大括号之前的number是指定返回值的类型为number
    return a + b
}

let result = sum(123, 456) // result是number类型
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607185255475.png" alt="image-20230607185255475" style="zoom:50%;" />

## 2.2 变量类型

|  类型   |       例子       |              描述              |
| :-----: | :--------------: | :----------------------------: |
| number  |   1，-33，2.5    |            任意数字            |
| string  |       'hi'       |           任意字符串           |
| boolean |   true、false    |       布尔值true或false        |
| 字面量  |      其本身      |  限制变量的值就是该字面量的值  |
|   any   |        *         |            任意类型            |
| unknown |        *         |         类型安全的any          |
|  void   | 空值(undefined)  |      没有值(或undefined)       |
|  never  |      没有值      |          不能是任何值          |
| object  | {name: '孙悟空'} |          任意的JS对象          |
|  array  |    [1, 2, 3]     |           任意JS数组           |
|  tuple  |      [4, 5]      | 元素，TS新增类型，固定长度数组 |
|  enum   |    enum{A, B}    |      枚举，TS中新增的类型      |

`chapter01/part1/03_types.ts`

1. number

```typescript
let x: number;

x = 10;
```

2. string

```typescript
let y: string

y = 'hello'
```

3. boolean

```typescript
let z = false;

z = true;
```

4. 字面量

```typescript
let a: 10
a = 10
// a = 11 // a的值只能为number类型的10 无法再为其他了
// 可以使用 | 来连接多个类型(联合类型)

let b: 'male' | 'female'
b = 'male'
b = 'female'
// b = 'hello'

let c: boolean | string
c = true
c = 'hello'
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607204338841.png" alt="image-20230607204338841" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607204356744.png" alt="image-20230607204356744" style="zoom:50%;" />

5. any

	* any表示的是任意类型，一个变量设置类型为any后相当于对该变量关闭了TS的类型检测
	* 使用TS时，不建议使用any类型（尽量避免）

```typescript
// any表示任意类型 可以任意赋值 一个变量设置类型为any后 相当于对该变量关闭了TS类型检测
// 使用TS时不建议使用any类型
// let d: any

// 声明变量如果不指定类型，则TS解析器会自动判断变量类型为any(隐式的any)
let d
d = 10
d = 'hello'
d = true
```

6. unknown
   * unknowm实际上就是一个类型安全的any
   * unknown类型的变量，不能直接赋值给其他变量

```typescript
// unknown表示未知类型的值
let e: unknown
e = 10
e = 'hello'
e = true
```

*any类型的变量可以赋值给任意变量，但unknown类型的变量不能直接赋值给其他变量*

```typescript
// d的类型是any 它可以赋值给任意变量
let s: string
// s = d // 这里赋值完之后 s的类型会从string变成boolean

e = 'hello'
// unknown 实际上就是一个类型安全的any
// unknown类型的变量，不能直接赋值给其他变量
if (typeof e === 'string') {
    s = e
}
```

这种需要把unknown类型变量赋给其他变量的情况下，我们可以使用到**类型断言**

```typescript
// 类型断言 告诉编译器变量e就是字符串类型 可以让编译器不报错 确保我们写的是对的
let e: unknown
let s: string
e = 'hello'
/* 
* 语法：
*   变量 as 类型
*   <类型>变量
*/
s = e as string
s = <string>e
```

7. void

​	void用来表示空值，以函数为例，就表示没有返回值（或返回undefined）的函数

```typescript
// void原来表示空，以函数为例，就表示没有返回值的函数
function fn(): void{

}
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607205715167.png" alt="image-20230607205715167" style="zoom:50%;" />

8. never

   never表示永远不会返回结果 没有值（比较少用，一般是用来抛出错误）

   ```typescript
   // never表示永远不回返回结果
   function fn2(): never{
       throw new Error('报错了！！')
   }
   ```

   
   
8. object

   1. `{}`用来指定对象中可以包含哪些属性

   `chapter01/part1/04_types.ts`
   
   ```typescript
   /*  
       语法：{属性名：属性值，属性名：属性值}
       在属性名后面加上？，表示属性是可选的
   */
   let b: {name: string, age?:number};
   
   b = {}; //没有的话就会报错
   b = {name: "孙悟空", age: 18};
   
   let c1: {name: string, a?:number, b?:number};
   c1 = {name:"猪八戒", a:1, b:2,c:3} //会报错，多余了c
   
   ```
   
   
   
   2. `[propName: string]: any`可以表示任意类型的属性
   
   ```typescript
   // [propName: string]: any 表示任意类型的属性
   let c1: {name: string, [propName: string]: any}
   c1 = {name: '猪八戒', age: 18, gender: '男'}
   ```
   
   <img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230608153214258.png" alt="image-20230608153214258" style="zoom:50%;" />

​		**设置函数结构的类型声明**

这个可以写成类似于箭头函数的形式来定义类型

```typescript
/*
*   设置函数结构的类型声明
*       语法:   (形参: 类型, 形参: 类型, ...) => 返回值
*/
let d1: (a: number, b: number) => number
d1 = function(n1, n2): number{
    return n1 + n2
}
```

11. array

```typescript
/*
*   数组的类型声明
*       类型[]
*       Array<类型>    
* */
// string[] 表示字符串数组
let e1: string[]
e1 = ['a', 'b', 'c']

// number[] 表示数值数组
let f: number[]

let g: Array<number>
g = [1, 2, 3]
```

12. tuple（ts新增类型）

​	tuple(元组)：就是固定长度的数组

```typescript
/*
*   元组：就是固定长度的数组
*       语法：[类型, 类型, 类型]
*/
let h: [string, number]
h = ['hello', 123]
```

13. enum（ts新增类型）

​	枚举可以把所有可能的值都列举出来

```typescript
/*
*   enum 枚举
*/
enum Gender{
    Male,
    Female
}
let i: {name: string, gender: Gender}
i = {
    name: '孙悟空',
    gender: Gender.Male
}
console.log(i.gender === Gender.Male);
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230608154158328.png" alt="image-20230608154158328" style="zoom:50%;" />

​	**&表示同时满足，且的意思**

```typescript
// & 表示同时，且
let j: {name: string} & {age: number}
j = {name: '孙悟空', age: 18}
```

​	**类型的别名** 这个其实就是自定义数据类型 让我们能够省下代码量的操作

```typescript
// 类型别名
type myType = 1 | 2 | 3 | 4 | 5
let k: myType
let l: myType
let m: myType
```

# 3. TypeScript：编译选项

## 3.1 自动编译的两种方法

	* `tsc xxx.ts -w` 能够对**单个ts文件**进行监视，若有修改则会自动重新编译
	* 新建一个`tsconfig.json`文件，里面什么都不写，然后在命令行执行`tsc -w`可以对**所有ts文件**进行监视，若有修改则会自动重新编译

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230608164028418.png" alt="image-20230608164028418" style="zoom:50%;" />

## 3.2 tsconfig.json文件

​	**tsconfig.json是ts编译器的配置文件，ts编译器可以根据它的信息来对代码进行编译**

`chapter01/part2/tsconfig.json`

介绍里面的配置项：

1. include

   1. 用来表示需要被编译的ts文件目录
   2. 路径：`**`表示任意目录，`*`表示任意文件

   ```json
   "include": [
   "./src/**/*"
   ]
   ```

2. exclude

   1. 用来表示不需要被编译的文件目录
   2. 默认值`["node_moudles", "bower_components", "jspm_packages"]`

   ```json
   "exclude": [
       "./src/hello/**/*"
   ]
   ```

3. extends

   * 定义被继承的配置文件

   ```json
   //表示当前配置文件中会自动包含config目录下base.json中的所有配置信息
   "extends": "./configs/base"
   ```

4. files

   * 指定被编译文件的列表，只有需要编译的文件少时才会用到

   ```json
   "files": [
   	"core.ts",
   	"sys.ts",
   	"types.ts"
   ]
   ```

5. **compirOptions（重要，编译器的选项）

   *complierOptions有很多的子选项*

   ```json
       // 编译器选项
       "compilerOptions": {
           
           // target用来指定ts被编译为的ES版本
           //'es3', 'es5', 'es6(es2015)', 'es2016', 'es2017', 'es2018', 'es2019', 'es2020', 'es2021', 'es2022' 'esnext'.
           "target": "es2015",
   
           // moudle 指定要使用的模块化的规范
           //'none', 'commonjs', 'amd', 'system', 'umd', 'es6(es2015)', 'es2020', 'esnext'
           "module": "es2015",
   
           // lib 用来指定项目中要使用的库 一般我们不会设置它
           // "lib": []
   
           // outDir 用来指定编译后文件所在的目录
           "outDir": "./dist",
   
           // outFile 将代码合并为一个文件
           // 设置outfFile后，所以的全局作用域中的代码会合并到同一个文件中
           // "outFile": "./dist/app.js"
   
           // 是否对js文件进行编译 默认是false
           "allowJs": true,
   
           // 是否检查js代码是否符合语法规范 默认是false
           "checkJs": true,
   
           // 是否移除注释 默认是false
           "removeComments": true,
   
           // 是否不生成编译后的文件 默认是false
           "noEmit": false,
   
           // 当有错误时是否不生产编译后的文件 默认是false
           "noEmitOnError": false,
   
           // 下方所有严格检查的总开关 默认是false 如果相同的话可以直接用这个，下面四个省略
           "strict": false,
   
           // 用来设置编译后的文件是否使用严格模式 默认是true
           "alwaysStrict": false,
   
           // 不允许隐式的any类型 默认是false
           "noImplicitAny": false,
   
           // 不允许不明确类型的this 默认是false
           "noImplicitThis": false,
   
           // 严格的检查空值 默认是false
           "strictNullChecks": false,
       }
   ```

   