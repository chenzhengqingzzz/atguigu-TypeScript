# TypeScript学习

# 1. TypeScript：初体验

## 1.1 TypeScript概述

![请添加图片描述](https://img-blog.csdnimg.cn/ee7cf4510b614e69bd0685283072d17f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JlcnRpbA==,size_16,color_FFFFFF,t_70)

**TS增加了什么？**

1. 类型
2. 支持ES的新特性
3. 添加ES不具备的新特性，比如接口、枚举...
4. 丰富的配置选项，比如可以设置编译成任意版本的ES
5. 强大的开发工具

## 1.2 TypeScript开发环境的搭建

1. 下载Node.js
2. 安装Node.js
3. 使用npm全局安装TypeScript
   1. 进入命令行
   2. 输入：`npm i -g typescript`(Mac用户要进入sudo)
4. 创建一个ts文件
5. 使用tsc命令对ts文件进行编译
   1. 进入命令行
   2. 进入ts文件所在目录
   3. 执行命令：`tsc xxx.ts`

## 1.3 第一个案例

	* 新建一个空文件夹 创建hello.ts文件

`chapter01/part1/01_helloTS.ts`

```typescript
console.log('Hello TS');
```

	* 在命令行使用tsc命令编译

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607152352046.png" alt="image-20230607152352046" style="zoom:50%;" />

我们就发现编译完成后生成了js文件 这就是tsc编译器的作用

# 2. TypeScript：类型声明和变量类型

## 2.1 类型声明

	* 直接在变量声明后面加

`chapter01/part2/02_basis.ts`

```typescript
// 表示我们声明一个变量a，同时指定它的类型为number
let a: number

// a的类型设置为了number，a的值只能是数字
a = 10
a = 33
// a = 'hello' // 此行代码会报错 因为变量a的类型是number 不能赋值字符串 但是可以编译成js
let b: string
// b = 123
```

	* 如果变量的声明和赋值是同时进行的，TS可以自动对变量类型进行检测

```typescript
// 声明完变量直接进行赋值
// let c: boolean = true

// 如果变量的声明和赋值是同时进行的，ts可以自动对变量进行类型检测
let c = false
c = true
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607185059956.png" alt="image-20230607185059956" style="zoom:50%;" />

	* 此外我们还可以对函数的参数、返回值的类型进行声明

```typescript
// JS中的函数是不考虑参数的类型和个数的
// function sum(a, b){
//     return a + b
// }
// console.log(sum(123, 456)) // 579
// console.log(sum(123, '456')); // '123456'

function sum(a: number, b: number): number{
    // 大括号之前的number是指定返回值的类型为number
    return a + b
}

let result = sum(123, 456) // result是number类型
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607185255475.png" alt="image-20230607185255475" style="zoom:50%;" />

## 2.2 变量类型

|  类型   |       例子       |              描述              |
| :-----: | :--------------: | :----------------------------: |
| number  |   1，-33，2.5    |            任意数字            |
| string  |       'hi'       |           任意字符串           |
| boolean |   true、false    |       布尔值true或false        |
| 字面量  |      其本身      |  限制变量的值就是该字面量的值  |
|   any   |        *         |            任意类型            |
| unknown |        *         |         类型安全的any          |
|  void   | 空值(undefined)  |      没有值(或undefined)       |
|  never  |      没有值      |          不能是任何值          |
| object  | {name: '孙悟空'} |          任意的JS对象          |
|  array  |    [1, 2, 3]     |           任意JS数组           |
|  tuple  |      [4, 5]      | 元素，TS新增类型，固定长度数组 |
|  enum   |    enum{A, B}    |      枚举，TS中新增的类型      |

`chapter01/part1/03_types.ts`

1. number

```typescript
let x: number;

x = 10;
```

2. string

```typescript
let y: string

y = 'hello'
```

3. boolean

```typescript
let z = false;

z = true;
```

4. 字面量

```typescript
let a: 10
a = 10
// a = 11 // a的值只能为number类型的10 无法再为其他了
// 可以使用 | 来连接多个类型(联合类型)

let b: 'male' | 'female'
b = 'male'
b = 'female'
// b = 'hello'

let c: boolean | string
c = true
c = 'hello'
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607204338841.png" alt="image-20230607204338841" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607204356744.png" alt="image-20230607204356744" style="zoom:50%;" />

5. any

	* any表示的是任意类型，一个变量设置类型为any后相当于对该变量关闭了TS的类型检测
	* 使用TS时，不建议使用any类型（尽量避免）

```typescript
// any表示任意类型 可以任意赋值 一个变量设置类型为any后 相当于对该变量关闭了TS类型检测
// 使用TS时不建议使用any类型
// let d: any

// 声明变量如果不指定类型，则TS解析器会自动判断变量类型为any(隐式的any)
let d
d = 10
d = 'hello'
d = true
```

6. unknown
   * unknowm实际上就是一个类型安全的any
   * unknown类型的变量，不能直接赋值给其他变量

```typescript
// unknown表示未知类型的值
let e: unknown
e = 10
e = 'hello'
e = true
```

*any类型的变量可以赋值给任意变量，但unknown类型的变量不能直接赋值给其他变量*

```typescript
// d的类型是any 它可以赋值给任意变量
let s: string
// s = d // 这里赋值完之后 s的类型会从string变成boolean

e = 'hello'
// unknown 实际上就是一个类型安全的any
// unknown类型的变量，不能直接赋值给其他变量
if (typeof e === 'string') {
    s = e
}
```

这种需要把unknown类型变量赋给其他变量的情况下，我们可以使用到**类型断言**

```typescript
// 类型断言 告诉编译器变量e就是字符串类型 可以让编译器不报错 确保我们写的是对的
let e: unknown
let s: string
e = 'hello'
/* 
* 语法：
*   变量 as 类型
*   <类型>变量
*/
s = e as string
s = <string>e
```

7. void

​	void用来表示空值，以函数为例，就表示没有返回值（或返回undefined）的函数

```typescript
// void原来表示空，以函数为例，就表示没有返回值的函数
function fn(): void{

}
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230607205715167.png" alt="image-20230607205715167" style="zoom:50%;" />

8. never

   never表示永远不会返回结果 没有值（比较少用，一般是用来抛出错误）

   ```typescript
   // never表示永远不回返回结果
   function fn2(): never{
       throw new Error('报错了！！')
   }
   ```

   
   
8. object

   1. `{}`用来指定对象中可以包含哪些属性

   `chapter01/part1/04_types.ts`
   
   ```typescript
   /*  
       语法：{属性名：属性值，属性名：属性值}
       在属性名后面加上？，表示属性是可选的
   */
   let b: {name: string, age?:number};
   
   b = {}; //没有的话就会报错
   b = {name: "孙悟空", age: 18};
   
   let c1: {name: string, a?:number, b?:number};
   c1 = {name:"猪八戒", a:1, b:2,c:3} //会报错，多余了c
   
   ```
   
   
   
   2. `[propName: string]: any`可以表示任意类型的属性
   
   ```typescript
   // [propName: string]: any 表示任意类型的属性
   let c1: {name: string, [propName: string]: any}
   c1 = {name: '猪八戒', age: 18, gender: '男'}
   ```
   
   <img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230608153214258.png" alt="image-20230608153214258" style="zoom:50%;" />

​		**设置函数结构的类型声明**

这个可以写成类似于箭头函数的形式来定义类型

```typescript
/*
*   设置函数结构的类型声明
*       语法:   (形参: 类型, 形参: 类型, ...) => 返回值
*/
let d1: (a: number, b: number) => number
d1 = function(n1, n2): number{
    return n1 + n2
}
```

11. array

```typescript
/*
*   数组的类型声明
*       类型[]
*       Array<类型>    
* */
// string[] 表示字符串数组
let e1: string[]
e1 = ['a', 'b', 'c']

// number[] 表示数值数组
let f: number[]

let g: Array<number>
g = [1, 2, 3]
```

12. tuple（ts新增类型）

​	tuple(元组)：就是固定长度的数组

```typescript
/*
*   元组：就是固定长度的数组
*       语法：[类型, 类型, 类型]
*/
let h: [string, number]
h = ['hello', 123]
```

13. enum（ts新增类型）

​	枚举可以把所有可能的值都列举出来

```typescript
/*
*   enum 枚举
*/
enum Gender{
    Male,
    Female
}
let i: {name: string, gender: Gender}
i = {
    name: '孙悟空',
    gender: Gender.Male
}
console.log(i.gender === Gender.Male);
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230608154158328.png" alt="image-20230608154158328" style="zoom:50%;" />

​	**&表示同时满足，且的意思**

```typescript
// & 表示同时，且
let j: {name: string} & {age: number}
j = {name: '孙悟空', age: 18}
```

​	**类型的别名** 这个其实就是自定义数据类型 让我们能够省下代码量的操作

```typescript
// 类型别名
type myType = 1 | 2 | 3 | 4 | 5
let k: myType
let l: myType
let m: myType
```

# 3. TypeScript：编译选项

## 3.1 自动编译的两种方法

	* `tsc xxx.ts -w` 能够对**单个ts文件**进行监视，若有修改则会自动重新编译
	* 新建一个`tsconfig.json`文件，里面什么都不写，然后在命令行执行`tsc -w`可以对**所有ts文件**进行监视，若有修改则会自动重新编译

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230608164028418.png" alt="image-20230608164028418" style="zoom:50%;" />

## 3.2 tsconfig.json文件

​	**tsconfig.json是ts编译器的配置文件，ts编译器可以根据它的信息来对代码进行编译**

`chapter01/part2/tsconfig.json`

介绍里面的配置项：

1. include

   1. 用来表示需要被编译的ts文件目录
   2. 路径：`**`表示任意目录，`*`表示任意文件

   ```json
   "include": [
   "./src/**/*"
   ]
   ```

2. exclude

   1. 用来表示不需要被编译的文件目录
   2. 默认值`["node_moudles", "bower_components", "jspm_packages"]`

   ```json
   "exclude": [
       "./src/hello/**/*"
   ]
   ```

3. extends

   * 定义被继承的配置文件

   ```json
   //表示当前配置文件中会自动包含config目录下base.json中的所有配置信息
   "extends": "./configs/base"
   ```

4. files

   * 指定被编译文件的列表，只有需要编译的文件少时才会用到

   ```json
   "files": [
   	"core.ts",
   	"sys.ts",
   	"types.ts"
   ]
   ```

5. **compirOptions（重要，编译器的选项）

   *complierOptions有很多的子选项*

   ```json
       // 编译器选项
       "compilerOptions": {
           
           // target用来指定ts被编译为的ES版本
           //'es3', 'es5', 'es6(es2015)', 'es2016', 'es2017', 'es2018', 'es2019', 'es2020', 'es2021', 'es2022' 'esnext'.
           "target": "es2015",
   
           // moudle 指定要使用的模块化的规范
           //'none', 'commonjs', 'amd', 'system', 'umd', 'es6(es2015)', 'es2020', 'esnext'
           "module": "es2015",
   
           // lib 用来指定项目中要使用的库 一般我们不会设置它
           // "lib": []
   
           // outDir 用来指定编译后文件所在的目录
           "outDir": "./dist",
   
           // outFile 将代码合并为一个文件
           // 设置outfFile后，所以的全局作用域中的代码会合并到同一个文件中
           // "outFile": "./dist/app.js"
   
           // 是否对js文件进行编译 默认是false
           "allowJs": true,
   
           // 是否检查js代码是否符合语法规范 默认是false
           "checkJs": true,
   
           // 是否移除注释 默认是false
           "removeComments": true,
   
           // 是否不生成编译后的文件 默认是false
           "noEmit": false,
   
           // 当有错误时是否不生产编译后的文件 默认是false
           "noEmitOnError": false,
   
           // 下方所有严格检查的总开关 默认是false 如果相同的话可以直接用这个，下面四个省略
           "strict": false,
   
           // 用来设置编译后的文件是否使用严格模式 默认是true
           "alwaysStrict": false,
   
           // 不允许隐式的any类型 默认是false
           "noImplicitAny": false,
   
           // 不允许不明确类型的this 默认是false
           "noImplicitThis": false,
   
           // 严格的检查空值 默认是false
           "strictNullChecks": false,
       }
   ```

   # 4. TypeScript：使用webpack打包ts代码
   
   ## 4.1 webpack的简单使用
   
   ​	*一般项目中我们不会直接编译ts代码，而是使用打包工具来进行*
   
   `chapter01/part3`
   
   	* 初始化项目：`npm init -y`
    * 安装依赖：`npm i -D webpack webpack-cli typescript ts-loader`（四个包）
      * webpack-cli——命令行工具
      * tsloader——将ts代码和webpack能整合在一起
   	* 新建配置文件
   
   `chapter01/part3/webpack.config.js`
   
   ```js
   // 引入一个包
   // node里的一个模块 主要作用就是帮助我们拼接路径
   const path = require('path')
   
   // webpack中的所有配置信息都应该写在moudle.exoprts中
   module.exports = {
   
       // 指定入口文件
       entry: './src/index.ts',
       
       // 指定打包文件所在目录
       output: {
           // 指定打包文件的目录
           // path: './dist,
           path: path.resolve(__dirname, 'dist'),
           // 打包后文件的名字
           filename: 'boundle.js',
       },
   
       // 指定wabpack打包时要使用的模块
       module: {
           // 指定loader要加载的规则
           rules: [
               {
                   // test指定的是规则生效的文件
                   test: /\.ts$/, // 以ts结尾的所有文件
                   // 要使用的loader
                   use: 'ts-loader',
                   // 要排除的文件
                   exclude: /node_moudles/
               }
           ]
       },
     
     // 用来设置引用模块，可以将这些文件识别为模块
     resolve: {
       extensions: ['.ts', '.js']
     }
   }
   ```
   
   ## 4.2 webpack中常用的插件
   
   1. **html-webpack-plugin**——html插件能帮助我们在打包的时候自动地生成html文件
   
   此外，我们得按装一个webpack插件`npm i -D html-webpack-plugin`，才能生成html文件
   
   在上面的基础上进行配置该插件
   
   `chapter01/part3/webpack.config.js`
   
   ```js
   // 引入一个包
   // node里的一个模块 主要作用就是帮助我们拼接路径
   const path = require('path')
   
   // webpack中的所有配置信息都应该写在moudle.exoprts中
   module.exports = {
   
       // 指定入口文件
       entry: './src/index.ts',
       
       // 指定打包文件所在目录
       output: {
           // 指定打包文件的目录
           // path: './dist,
           path: path.resolve(__dirname, 'dist'),
           // 打包后文件的名字
           filename: 'boundle.js',
       },
   
       // 指定wabpack打包时要使用的模块
       module: {
           // 指定loader要加载的规则
           rules: [
               {
                   // test指定的是规则生效的文件
                   test: /\.ts$/, // 以ts结尾的所有文件
                   // 要使用的loader
                   use: 'ts-loader',
                   // 要排除的文件
                   exclude: /node_moudles/
               }
           ]
       },
       
     // 配置webpack插件
     plugins: [
     		new HTMLWebpackPlugin({
     				title: '这是一个自定义title',
     				template: './src/index.html
     		})
     ]
     
     // 用来设置引用模块，可以将这些文件识别为模块
     resolve: {
       extensions: ['.ts', '.js']
     }
   }
   ```
   
   2. **webpack-dev-server**——该插件能够自动相应浏览器更新
   
      * 安装：`npm i -D webpack-dev-server`
      * 在start加入命令：
   
      `chapter01/part3/package.json`
   
      ```json
      ...
        "scripts": {
          "test": "echo \"Error: no test specified\" && exit 1",
          "build": "webpack",
          "start": "webpack serve --open --mode development"
        },
      ...
      ```
   
      这样就能在开发时实现热部署了
   
   3. **clean-webpack-plugin**——clean插件能在build前清空dist目录所有文件，避免旧文件的遗留
   
      * 安装：`npm i -D clean-webpack-plugin`
      * 使用
   
      `chapter01/part3/webpack.config.js`
   
      ```js
      // 引入一个包
      // node里的一个模块 主要作用就是帮助我们拼接路径
      const path = require('path')
      
      // webpack中的所有配置信息都应该写在moudle.exoprts中
      module.exports = {
      
          // 指定入口文件
          entry: './src/index.ts',
          
          // 指定打包文件所在目录
          output: {
              // 指定打包文件的目录
              // path: './dist,
              path: path.resolve(__dirname, 'dist'),
              // 打包后文件的名字
              filename: 'boundle.js',
          },
      
          // 指定wabpack打包时要使用的模块
          module: {
              // 指定loader要加载的规则
              rules: [
                  {
                      // test指定的是规则生效的文件
                      test: /\.ts$/, // 以ts结尾的所有文件
                      // 要使用的loader
                      use: 'ts-loader',
                      // 要排除的文件
                      exclude: /node_moudles/
                  }
              ]
          },
          
        // 配置webpack插件
        plugins: [
          	new CleanWebpackPlugin(),
        		new HTMLWebpackPlugin({
        				title: '这是一个自定义title',
        				template: './src/index.html
        		})
        ]
        
        // 用来设置引用模块，可以将这些文件识别为模块
        resolve: {
          extensions: ['.ts', '.js']
        }
      }
      ```
   
   ## 4.3 Babel的使用
   
   ​	为了使得代码能兼容不同的浏览器，我们需要使用babel工具（与webpack结合一起使用）

* 安装依赖`npm i -D @babel/core @babel/preset-env babel-loader core-js`（四个包）

  * @babel/core——babel核心的工具
  * @babel/preset-env——babel的预设环境
  * babel-loader——babel与webpack结合的工具
  * core-js——模拟js运行环境（使用的时候可以按需引入）

* 修改webpack配置文件

  在loader加载器中加入babel（loader中的执行顺序是从下往上，所以要将`ts-loader`放到最后）

  `chapter01/part3/webpack.config.js`

  ```js
  	//指定webpack打包时要使用的模块
      module: {
          // 指定要loader加载的规则
          rules: [
              {
                  // test指定的是规则生效的文件
                  test: /\.ts$/,//以ts结尾的文件
                  // 要使用的loader
                  use: [
                      // 配置babel
                      {
                          //指定加载器
                          loader: "babel-loader",
                          // 设置babel
                          options: {
                              //设置预定义的环境
                              presets: [
                                  [
                                      //指定环境的插件
                                      "@babel/preset-env",
                                      // 配置信息
                                      {
                                          // 要兼容的目标浏览器及版本
                                          targets: {
                                              "chrome": "58",
                                              "ie": "11"
                                          },
                                          //指定corejs的版本（根据package.json中的版本，只写整数）
                                          "corejs": "3",
                                          //使用corejs的方式 "usage"  表示按需加载
                                          "useBuiltIns": "usage" 
                                      }
  
                                  ]
                              ]
                          }
                      },
                      // 'babel-loader', //简化版的配置
                      'ts-loader'
                  ],
                  // 要排除的文件
                  exclude: /node_modules/
              }
          ]
      },
  
  ```

这样，webpack的基本配置就完成了 也是项目开发中常用的配置 下面是整合后的**最终配置文件**，开发时可以根据这个来做修改

**`webpack.config.js`**

```javascript
// 引入一个包
// node里的一个模块 主要作用就是帮助我们拼接路径
const path = require('path')
// 引入自动引入的html插件
const HTMLWebpackPlugin = require('html-webpack-plugin')
// 引入clean插件
const {CleanWebpackPlugin} = require('clean-webpack-plugin')

// webpack中的所有配置信息都应该写在moudle.exoprts中
module.exports = {

    // 指定入口文件
    entry: './src/index.ts',
    
    // 指定打包文件所在目录
    output: {
        // 指定打包文件的目录
        // path: './dist,
        path: path.resolve(__dirname, 'dist'),
        // 打包后文件的名字
        filename: 'boundle.js',
        // 是否让webpack打包的时候使用箭头函数 false代表不使用
        environment: {
            arrowFunction: true
        }
    },

    // 指定wabpack打包时要使用的模块
    module: {
        // 指定loader要加载的规则
        rules: [
            {
                // test指定的是规则生效的文件
                test: /\.ts$/, // 以ts结尾的所有文件
                // 要使用的loader
                use: [
                    // 配置babel
                    {
                        // 指定加载器
                        loader: 'babel-loader',
                        // 设置babel
                        options: {
                            // 这是预定义的环境
                            presets: [
                                [
                                    // 指定环境插件
                                    '@babel/preset-env',
                                    // 配置信息
                                    {
                                        targets: {
                                            // 要兼容的目标浏览器
                                            'chrome': '114',
                                        },
                                        // 指定corejs的版本
                                        'corejs': '3',
                                        // 使用corejs的方式 'usage'表示按需加载
                                        'useBuiltIns': 'usage'
                                    }
                                ]
                            ]
                        }
                    },
                    'ts-loader',
                ],
                // 要排除的文件
                exclude: /node_moudles/
            }
        ]
    },

    // 配置webpack插件
    plugins: [
        new HTMLWebpackPlugin({
            title: '这是一个自定义title',
            template: './src/index.html'
        }),
        new CleanWebpackPlugin()
    ],

    // 用来设置引用模块
    resolve: {
        extensions: ['.ts', '.js']
    }
}
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230609155149048.png" alt="image-20230609155149048" style="zoom:50%;" />

# 4. 面向对象

## 4.1 面向对象的概念 

面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。

- 举例来说：

  - 操作浏览器要使用的window对象
  - 操作网页要使用的document对象
  - 操作控制台要使用的console对象

  一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。

  在程序中所有的对象都被分成了两个部分：数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。

## 4.2 类（class）

要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。

`chapter02/part1/src/01_类的简介.ts`

```typescript
// 使用class关键字来定义一个类

/*
*   对象中主要包含了两个部分 属性、方法 我们都需要在类中明确的表示出来
            属性
            方法
*/
class Person {
    /*
    *   直接定义的属性是实例属性，需要通过对象的实例去访问
    *       const per = new Person()
    *       per.name
    *   使用static开头的属性是静态属性（类属性），可以通过类直接去访问
    *       Person.age 
    * 
    *   readonly开头的属性表示一个只读的属性 无法修改
    */
    // 定义属性
    // readonly name: string = '孙悟空'
    name = '孙悟空'
    // 在属性前使用static关键字可以定义类属性（静态属性）
    // static readonly age: number = 18
    age = 18

    // 定义方法
    /*
    *   类似静态属性，如果方法以static开头，则方法就是类方法（静态方法），可以直接通过类去调用
    */
    sayHello(){
        console.log('大家好');
        
    }
}

const per = new Person()

console.log(per);

// 通过这个类直接访问类属性（静态属性）
// console.log(Person.age);

// console.log(per.name);
// console.log(per.name = 'tom');

per.sayHello()
```

静态属性和静态方法不能通过实例（new出来的）去访问，只能指定那个类名去访问 这个和Java非常相似

使用tsc命令编译成js代码后放在html页面中运行的结果：

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230609165918062.png" alt="image-20230609165918062" style="zoom:50%;" />

## 4.3 构造函数和this

```typescript
class Dog{
    name: string
    age: number
    
    // constructor 被称为构造函数
    // 构造函数会在每一次对象创建的时候调用
    constructor(name: string, age: number){
        console.log('构造函数执行了');
        // 在实例方法中，this就表示当前的实例
        // 在构造函数中，当前对象就是当前新建的那个对象
        // 所以我们就可以通过this来向新建的对象中添加属性
        // console.log(this);
        this.name = name
        this.age = age
        
    }

    bark(){
        // alert('汪汪汪')
        // 在方法中可以用this来表示当前调用方法的实例
        console.log(this);
        
    }
}

const dog = new Dog('小黑', 4)
const dog2 = new Dog('小白', 2)

// console.log(dog);

dog.bark()
dog2.bark()
```

 我们这里定义的都是实例方法 我们创建类是为了让每一个实例都遵循类这个模板，然后制造出具体的对象实例 比如Dog这个类，我们如果直接在里面赋值`name = '旺财'`，那么我们创建的每一个对象里面，里面的name属性永远为旺财，这是不符合我们的要求的 

这个时候我们就需要用到`构造器（构造函数）` 它会在创建实例的时候调用 里面的this指向也将会是当前实例 这也就意味着我们可以在构造器里面赋值，只需要在创建对象的时候传入我们需要指定的值就行了

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230609173708838.png" alt="image-20230609173708838" style="zoom:50%;" />

## 4.4 继承

我们先来创建两个类 表示狗和猫 这两个类在创建实例的时候都会传入name和age属性 并且都会有sayHello方法

`chapter02/part1/03_继承.ts`

```typescript
    // 定义一个表示狗的类
    class Dog {
        name: string
        age: number

        constructor(name: string, age: number) {
            this.name = name
            this.age = age
        }

        sayHello() {
            console.log('汪汪汪');

        }
    }

    // 定义一个表示猫的类
    class Cat {
        name: string
        age: number

        constructor(name: string, age: number) {
            this.name = name
            this.age = age
        }

        sayHello() {
            console.log('喵喵喵');

        }
    }
    const dog = new Dog('旺财', 5)
    const cat = new Cat('咪咪', 3)
    console.log(dog);
    dog.sayHello()
    console.log(cat);
    cat.sayHello()
```

运行结果没有任何问题

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230609175326922.png" alt="image-20230609175326922" style="zoom:50%;" />

我们发现 在Dog和Cat这两个类中，除了sayHello方法中具体做的事情不一样之外 其余方面全部都一模一样 这也就意味着我们没有进行代码复用 所以我们可以把这两个地方的相同代码全都放在一个父类Animal中 然后让着两个类继承这个父类 

	* 使用**extends**继承后，子类将会拥有父类所有的方法和属性
	* 通过继承可以将多个类中共有的代码写在一个父类，这样只需要写一次即可让所有的子类都同时拥有父类中的属性和方法

```typescript
    // 定义一个Animal类
    class Animal {
        name: string
        age: number

        constructor(name: string, age: number) {
            this.name = name
            this.age = age
        }

        sayHello() {
            console.log('动物在叫');

        }
    }
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230609183148367.png" alt="image-20230609183148367" style="zoom:50%;" />

这个时候我们甚至可以在子类中添加子类独有的方法

```typescript
    class Dog extends Animal{

        // 在新类中添加一个方法 这个方法是Dog类独有的
        run(){
            console.log(`${this.name}在跑`);
        }

    }
...
    const dog = new Dog('旺财', 5)
    console.log(dog);
    dog.run()
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230609183618776.png" alt="image-20230609183618776" style="zoom:50%;" />

这个没问题 但是我们的Dog、Cat类都使用了相同的sayHello方法，我们都希望Dog的实例调用方法的时候输出汪汪汪，Cat的实例调用方法的时候输出喵喵喵 我们需要在类里面定义同名的方法，然后在里面写自己的逻辑就行了

* 如果子类中添加了和父类相同的方法，则子类方法会覆盖掉父类的方法。这种子类覆盖掉父类方法的形式，我们称为重写

```typescript
    class Dog extends Animal{

        // 在新类中添加一个方法 这个方法是Dog类独有的
        run(){
            console.log(`${this.name}在跑`);
        }

        // 重写方法 让类有自己的特点
        sayHello(){
            console.log('汪汪汪');
            
        }

    }

    // 定义一个表示猫的类
    // 使Cat类继承Animal类
    class Cat extends Animal{
        // 重写方法
        sayHello(){
            console.log('喵喵喵');
            
        }
    }
    const dog = new Dog('旺财', 5)
    const cat = new Cat('咪咪', 3)
    console.log(dog);
    dog.sayHello()
    dog.run()
    console.log(cat);
    cat.sayHello()
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230609183845817.png" alt="image-20230609183845817" style="zoom:50%;" />

完整代码奉上：

```typescript
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-06-09 17:40:20
 * @LastEditors: 陈正清MacPro
 * @LastEditTime: 2023-06-09 18:38:35
 * @FilePath: /atguigu-TypeScript/chapter02/part1/src/03_继承.ts
 * @Description: 继承相关知识
 * 
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved. 
 */
// 创建函数作用域 避免和其他文件的命名重复
(function () {

    // 定义一个Animal类
    class Animal {
        name: string
        age: number

        constructor(name: string, age: number) {
            this.name = name
            this.age = age
        }

        sayHello() {
            console.log('动物在叫');
        }
    }

    /*
    *  Dog extends Animal
    *       - 此时Animal被称为父类，Dog被称为子类
    *       — 使用继承后，子类将会拥有父类所有的方法和属性
    *       - 通过继承 我们可以将多个类中共有的代码写在一个父类中
    *          这样只需要写一次即可让所有的子类都同时拥有父类中的属性
    *          如果希望在子类中添加一些父类中没有的属性或方法，直接加就行
    *       - 如果在子类中添加了和父类相同的方法，则子类会覆盖掉父类的方法
    *          这种子类覆盖父类方法的形式我们称之为方法重写
    */
    // 定义一个表示狗的类
    // 使Dog类继承Animal类
    class Dog extends Animal{

        // 在新类中添加一个方法 这个方法是Dog类独有的
        run(){
            console.log(`${this.name}在跑`);
        }

        // 重写方法 让类有自己的特点
        sayHello(){
            console.log('汪汪汪');
            
        }

    }

    // 定义一个表示猫的类
    // 使Cat类继承Animal类
    class Cat extends Animal{
        // 重写方法
        sayHello(){
            console.log('喵喵喵');
            
        }
    }
    const dog = new Dog('旺财', 5)
    const cat = new Cat('咪咪', 3)
    console.log(dog);
    dog.sayHello()
    dog.run()
    console.log(cat);
    cat.sayHello()

})()
```

## 4.5 super

	* 在类的方法中 super表示当前类的父类（也称超类

**如果在子类中写了构造函数，则在子类构造函数中必须对父类的构造函数进行调用**

```typescript
// 创建函数作用域 避免和其他文件的命名重复
(function () {
    class Animal {
        name: string
        constructor(name: string) {
            this.name = name
        }
        sayHello() {
            console.log('动物在叫');

        }
    }

    class Dog extends Animal {

        age: number
        constructor(name: string, age: number){
            // 如果在子类中写了构造函数，在子类的构造函数中必须对父类的构造函数进行调用
            // 因为在子类写构造函数 本质也是方法重写 如果没有带上父类的构造函数 那么就无法获得父类的属性 也就不叫继承了
            super(name) // 调用父类的构造函数 并且传入属性
            this.age = age
        }
        sayHello() {
            // 在类的方法中 super就表示当前类的父类
            super.sayHello()

            console.log('汪汪汪');
            
        }
    }

    const dog = new Dog('旺财', 3)
    dog.sayHello()
    console.log(dog);
    
})()
```

如果在子类中写了构造函数，在子类的构造函数中必须对父类的构造函数进行调用`super()`

 因为在子类写构造函数 本质也是方法重写 如果没有带上父类的构造函数 那么就无法获得父类的属性 也就不叫继承了

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230610183514547.png" alt="image-20230610183514547" style="zoom:50%;" />
